{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nexports.getBoundPosition = getBoundPosition;\nexports.getControlPosition = getControlPosition;\nexports.snapToGrid = snapToGrid;\nvar _shims = require(\"./shims\");\nvar _domFns = require(\"./domFns\");\n/*:: import type Draggable from '../Draggable';*/\n/*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/\n/*:: import type DraggableCore from '../DraggableCore';*/\nfunction getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/{\n  // If no bounds, short-circuit and move on\n  if (!draggable.props.bounds) return [x, y];\n\n  // Clone new bounds\n  let {\n    bounds\n  } = draggable.props;\n  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n  const node = findDOMNode(draggable);\n  if (typeof bounds === 'string') {\n    const {\n      ownerDocument\n    } = node;\n    const ownerWindow = ownerDocument.defaultView;\n    let boundNode;\n    if (bounds === 'parent') {\n      boundNode = node.parentNode;\n    } else {\n      // Flow assigns the wrong return type (Node) for getRootNode(),\n      // so we cast it to one of the correct types (Element).\n      // The others are Document and ShadowRoot.\n      // All three implement querySelector() so it's safe to call.\n      const rootNode = node.getRootNode() /*: any*/ /*: Element*/;\n      boundNode = rootNode.querySelector(bounds);\n    }\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n      throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n    }\n    const boundNodeEl /*: HTMLElement*/ = boundNode; // for Flow, can't seem to refine correctly\n    const nodeStyle = ownerWindow.getComputedStyle(node);\n    const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);\n    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n    bounds = {\n      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n      right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n      bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n    };\n  }\n\n  // Keep x and y below right and bottom limits...\n  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);\n\n  // But above left and top limits.\n  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n  return [x, y];\n}\nfunction snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/{\n  const x = Math.round(pendingX / grid[0]) * grid[0];\n  const y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\nfunction canDragX(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n}\nfunction canDragY(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n}\n\n// Get {x, y} positions from event.\nfunction getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/{\n  const touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\n  const node = findDOMNode(draggableCore);\n  // User can provide an offsetParent if desired.\n  const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n}\n\n// Create an data object exposed by <DraggableCore>'s events\nfunction createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/{\n  const isStart = !(0, _shims.isNum)(draggable.lastX);\n  const node = findDOMNode(draggable);\n  if (isStart) {\n    // If this is our first move, use the x and y as last coords.\n    return {\n      node,\n      deltaX: 0,\n      deltaY: 0,\n      lastX: x,\n      lastY: y,\n      x,\n      y\n    };\n  } else {\n    // Otherwise calculate proper values.\n    return {\n      node,\n      deltaX: x - draggable.lastX,\n      deltaY: y - draggable.lastY,\n      lastX: draggable.lastX,\n      lastY: draggable.lastY,\n      x,\n      y\n    };\n  }\n}\n\n// Create an data exposed by <Draggable>'s events\nfunction createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/{\n  const scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + coreData.deltaX / scale,\n    y: draggable.state.y + coreData.deltaY / scale,\n    deltaX: coreData.deltaX / scale,\n    deltaY: coreData.deltaY / scale,\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n}\n\n// A lot faster than stringify/parse\nfunction cloneBounds(bounds /*: Bounds*/) /*: Bounds*/{\n  return {\n    left: bounds.left,\n    top: bounds.top,\n    right: bounds.right,\n    bottom: bounds.bottom\n  };\n}\nfunction findDOMNode(draggable /*: Draggable | DraggableCore*/) /*: HTMLElement*/{\n  const node = draggable.findDOMNode();\n  if (!node) {\n    throw new Error('<DraggableCore>: Unmounted during event!');\n  }\n  // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n  return node;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","canDragX","canDragY","createCoreData","createDraggableData","getBoundPosition","getControlPosition","snapToGrid","_shims","require","_domFns","draggable","x","y","props","bounds","cloneBounds","node","findDOMNode","ownerDocument","ownerWindow","defaultView","boundNode","parentNode","rootNode","getRootNode","querySelector","HTMLElement","Error","boundNodeEl","nodeStyle","getComputedStyle","boundNodeStyle","left","offsetLeft","int","paddingLeft","marginLeft","top","offsetTop","paddingTop","marginTop","right","innerWidth","outerWidth","paddingRight","marginRight","bottom","innerHeight","outerHeight","paddingBottom","marginBottom","isNum","Math","min","max","grid","pendingX","pendingY","round","axis","e","touchIdentifier","draggableCore","touchObj","getTouch","offsetParent","body","offsetXYFromParent","scale","isStart","lastX","deltaX","deltaY","lastY","coreData","state"],"sources":["C:/Users/Asus/Downloads/plot-diagram-app/node_modules/react-draggable/build/cjs/utils/positionFns.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nexports.getBoundPosition = getBoundPosition;\nexports.getControlPosition = getControlPosition;\nexports.snapToGrid = snapToGrid;\nvar _shims = require(\"./shims\");\nvar _domFns = require(\"./domFns\");\n/*:: import type Draggable from '../Draggable';*/\n/*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/\n/*:: import type DraggableCore from '../DraggableCore';*/\nfunction getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/{\n  // If no bounds, short-circuit and move on\n  if (!draggable.props.bounds) return [x, y];\n\n  // Clone new bounds\n  let {\n    bounds\n  } = draggable.props;\n  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n  const node = findDOMNode(draggable);\n  if (typeof bounds === 'string') {\n    const {\n      ownerDocument\n    } = node;\n    const ownerWindow = ownerDocument.defaultView;\n    let boundNode;\n    if (bounds === 'parent') {\n      boundNode = node.parentNode;\n    } else {\n      // Flow assigns the wrong return type (Node) for getRootNode(),\n      // so we cast it to one of the correct types (Element).\n      // The others are Document and ShadowRoot.\n      // All three implement querySelector() so it's safe to call.\n      const rootNode = ((node.getRootNode() /*: any*/) /*: Element*/);\n      boundNode = rootNode.querySelector(bounds);\n    }\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n      throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n    }\n    const boundNodeEl /*: HTMLElement*/ = boundNode; // for Flow, can't seem to refine correctly\n    const nodeStyle = ownerWindow.getComputedStyle(node);\n    const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);\n    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n    bounds = {\n      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n      right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n      bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n    };\n  }\n\n  // Keep x and y below right and bottom limits...\n  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);\n\n  // But above left and top limits.\n  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n  return [x, y];\n}\nfunction snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/{\n  const x = Math.round(pendingX / grid[0]) * grid[0];\n  const y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\nfunction canDragX(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n}\nfunction canDragY(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n}\n\n// Get {x, y} positions from event.\nfunction getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/{\n  const touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\n  const node = findDOMNode(draggableCore);\n  // User can provide an offsetParent if desired.\n  const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n}\n\n// Create an data object exposed by <DraggableCore>'s events\nfunction createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/{\n  const isStart = !(0, _shims.isNum)(draggable.lastX);\n  const node = findDOMNode(draggable);\n  if (isStart) {\n    // If this is our first move, use the x and y as last coords.\n    return {\n      node,\n      deltaX: 0,\n      deltaY: 0,\n      lastX: x,\n      lastY: y,\n      x,\n      y\n    };\n  } else {\n    // Otherwise calculate proper values.\n    return {\n      node,\n      deltaX: x - draggable.lastX,\n      deltaY: y - draggable.lastY,\n      lastX: draggable.lastX,\n      lastY: draggable.lastY,\n      x,\n      y\n    };\n  }\n}\n\n// Create an data exposed by <Draggable>'s events\nfunction createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/{\n  const scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + coreData.deltaX / scale,\n    y: draggable.state.y + coreData.deltaY / scale,\n    deltaX: coreData.deltaX / scale,\n    deltaY: coreData.deltaY / scale,\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n}\n\n// A lot faster than stringify/parse\nfunction cloneBounds(bounds /*: Bounds*/) /*: Bounds*/{\n  return {\n    left: bounds.left,\n    top: bounds.top,\n    right: bounds.right,\n    bottom: bounds.bottom\n  };\n}\nfunction findDOMNode(draggable /*: Draggable | DraggableCore*/) /*: HTMLElement*/{\n  const node = draggable.findDOMNode();\n  if (!node) {\n    throw new Error('<DraggableCore>: Unmounted during event!');\n  }\n  // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n  return node;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}